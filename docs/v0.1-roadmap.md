# Ghostlang v0.1.0 Roadmap (Execution Plan)

**Status Date:** 2025-10-04  
**Release Tagging:** Held until maintainers approve (do not tag automatically)

This plan sequences the remaining work to deliver Ghostlang v0.1.0 across parser, VM, standard library, and ecosystem tooling. It builds on the existing `parser-phase-a-plan.md`, `CODEX.md`, and `GROVE_HYBRID_UPDATE.md` documents.

---

## Phase A — Control Flow Parity (in-flight)

**Goal:** Complete Lua-style parity for control flow on top of the numeric `for` and `repeat ... until` support already merged.

### Outstanding Tasks
- [x] **Generic `for` loops** (`for k, v in iterator do ... end`)
  - Parser supports iterator headers with optional second variable.
  - VM iterator protocol (`iterator_setup`, `iterator_next`) with runtime safety checks.
  - Built-in `pairs`/`ipairs` now yield ScriptIterator instances consumable by the VM.
- [x] **Local/anonymous function parsing**
  - `local function foo() ... end` desugars into scoped ScriptFunction definitions.
  - Anonymous function expressions (`function (...) ... end`) compile as first-class values.
  - Loop/function scopes cooperate with `break` / `continue` unwinding.
- [x] **Loop hygiene checks**
  - Numeric `for` rejects zero-step configurations with `InvalidNumericStep` errors.
  - Continue/break paths validated through iterator and numeric loop continuations.

### Deliverables
- Parser + VM patches on `feature/parser-phase-a` branch.
- Updated unit/integration tests covering the new syntax forms.
- Grove grammar/fixtures mirroring the new constructs (tracked via `GROVE_HYBRID_UPDATE.md`).

---

## Phase B — Functions & Locals

**Goal:** Make user-defined functions first-class, with robust return semantics.

### Core Work
- [ ] **Function declarations & expressions**
  - Parse global/local named functions and anonymous expressions.
  - Emit `ScriptFunction` bytecode objects with captured scope depth.
- [ ] **Call stack & returns**
  - Support single and *multiple* return values; update VM register convention.
  - `return` inside nested blocks unwinds to function scope.
  - Arity checking, varargs (`...`) groundwork.
- [ ] **Closures & upvalues**
  - Capture outer-scope locals when returning inner functions.
  - Implement reference counting / lifetime rules matching existing `ScriptFunction` retention APIs.
- [ ] **Error handling scaffolding**
  - Introduce `pcall`/`error` stubs to be fleshed out post v0.1.0 (optional but plan structure now).

### Tests & Docs
- Expand integration suite (`tests/integration_test.zig`) with function scenarios.
- Document function syntax (brace + Lua) and return semantics in language guide.

---

## Phase C — Data & Standard Library

Execute Phase C immediately after Phase B merges.

### 1. Table & Array APIs
- [ ] Replace stubs in `ScriptEngine.registerEditorHelpers` with full implementations:
  - `createArray`, `arrayPush`, `arrayPop`, `arrayLength`, `arrayGet`, `arraySet`.
  - `createObject`, `objectSet`, `objectGet`, `objectKeys` (optional), respecting sandbox copying rules.
- [ ] Implement built-in iterator helpers:
  - `pairs(table)` → returns iterator closure for key/value traversal. ✅ (iterator objects now emitted in Phase A)
  - `ipairs(array)` → sequential iterator honoring 1-based indexing. ✅ (iterator objects now emitted in Phase A)
  - Confirm compatibility with generic `for` loop bytecode.
- [ ] Table literal sugar & method calls
  - Ensure `obj:method(args)` binds `self` correctly when method obtained via table lookup.
  - Validate nested table/array literal creation interacts with garbage collection semantics.

### 2. String Helpers
- [ ] Implement the placeholder functions in `ScriptEngine`:
  - `substring(str, start, [end])`
  - `indexOf(str, search, [fromIndex])`
  - `replace(str, search, replacement)`
- [ ] Add Lua-equivalent APIs:
  - `match`, `find`, `gsub`, `sub`, `upper`, `lower`, `format`, `len`.
  - Ensure deterministic behavior (no locale dependence, sandbox-friendly).
- [ ] Extend the standard library registry with safe wrappers exposed as global functions or string methods.

### 3. Validation
- [ ] Write corpus fixtures covering table iteration and string operations.
- [ ] Expand runtime integration tests (tables + strings) and fuzzers (string-heavy inputs).
- [ ] Update documentation: language guide, migration guide, Grove highlights/locals for new methods.

---

## Ecosystem Synchronization

These threads run in parallel with the core phases.

- **GShell**
  - Port shipped plugins/configs to the dual-syntax style once Phase A/B land.
  - Add CI smoke tests executing each plugin through `ScriptEngine` with new APIs.
- **Grove**
  - Follow the workflow in `GROVE_HYBRID_UPDATE.md` whenever grammar changes, keeping the full vendored repo.
- **Grim**
  - Build scripting adapter and sample plugins once function/string APIs are stable.
- **Quality Gates**
  - Stand up parser/VM fuzzing harness, performance benchmarks, and release documentation before tagging v0.1.0.

---

## Sequencing Summary

1. **Phase A wrap-up** → Merge control-flow parity, update Grove fixtures.
2. **Phase B implementation** → Functions, returns, closures, integration tests.
3. **Phase C execution** → Data structures + string library.
4. **Ecosystem updates** → GShell plugins, Grove grammar sync, Grim adapter.
5. **Quality & Docs** → Fuzzing, performance baselines, final documentation pass.
6. ✅ **Tag v0.1.0** (only when maintainers approve; do not auto-tag).

Keep this document updated as tasks complete to maintain shared visibility across teams.
